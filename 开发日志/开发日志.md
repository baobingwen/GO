### 2024_09_08

1. 开始开发围棋游戏
2. 绘制棋盘

### 2024_09_09

1. 调整棋盘大小
2. 初步处理落子，存在落子位置识别不准确问题
3. 完善落子位置判定
4. 处理落子逻辑（禁入点），尚未考虑劫争
5. 尝试建立落子顺序数据集，采用全盘记录模式，尚未知晓是否成功
6. 修复判断禁入点bug，因为将'='写成'=='浪费2小时

后续进展
1. 落子顺序数据集的建立
2. 劫争的判定

## 2024_09_10

1. 重构落子体系，对象化，实现前后端的归一化
2. player == 'B' or 'W' color注意要设定为已预设的常量（如BLACK）
3. 实现顺序结构的落子（前后端
4. 初步尝试落子逻辑（吃子），采用对没颗棋子进行搜索，全局搜索（出现与禁入点矛盾的问题）
5. 解决禁入点和吃子矛盾的问题（尚未完成）
6. 前端就做全刷新，后端就做全仿真、全模拟

```
争议点：
使用全盘全记录 or 使用单个棋子顺序记录
都要
```

```
矛盾点：
禁入点和吃子
全局重构逻辑
```

1. 设置主手判定，自己下的棋会失去检测（修复不能提子bug，出现下入禁入区的bug）
2. 设置只下黑棋、只下白棋、正常模式按钮及实现相应逻辑
3. 设置当前落子颜色提示，存在设置模式时提示滞后的bug（无法同步前后端棋子颜色状态）
4. 成功提交上传至github

## 2024_09_11

```
发现问题：吃子判定存在同时提两片不同区域的子时不能提干净
疑似逻辑问题：目前为从单一棋子出发的判定，不是全盘判定全部死子
尝试解决：利用死子判定标记全盘敌方死子，一次清空
新路径：借鉴lizzieyzy的后端
结果：失败，代码太长看不懂，功能太多无从下手
```

## 2024_09_12

我现在一看到后端的那坨逻辑就头疼，实践证明步子迈的太大容易卡着蛋
```
重新开了一个项目：井字棋
调整了一下项目结构使其变得更加正式
```
暂停更新中

## 2024_09_14

井字棋基础部分开发完毕，继续开发GO

```
Q.F. 发现没懂pygame的Surface
reso. 重学
Q.F. 保存背景不完全，应该保存棋板背景、空白棋局为默认背景
reso. 今天太累了不想改
Q.F. board_size 存在歧义，容易将前端(宽度)和后端(路数)混淆
modi. 将路数board_size修改为board_dimension
Q.F. 我不想用size，因为存在歧义
modi. 将含size的变量名全部修改
    tile_size 改为 cell_edge_len
    border_size 改为 border_len
modi. 将棋盘宽高由self.board_dimension * self.cell_edge_len
修改为(self.board_dimension - 1) * self.cell_edge_len
modi. 将边界宽度由40修改为self.cell_edge_len
modi. 调整注释
modi. 规范用语：棋局专用于后端，棋盘专精于前端
```

## 2024_09_15

```
>> 解决昨天留下的背景保存问题，争取整合化
modi. 创建test4.py，用于测试背景保存，已成功
QED. 已解决问题，使用screen.copy()获取surface可留存背景
modi. 分离前后端代码区
```

Fatal:后端围棋规则设定不完备
```
根据之前矛盾点的经验，
需要将围棋规则全部打通才能写出完备规则，实现落子逻辑

reso. 
棋子：坐标、颜色、手数
棋局：
1. 全盘记录
2. 棋子链记录

基本落子逻辑：在原有棋局上加上这一颗子
1. 如果不存在无气的棋子、棋块，可以落下
2. 如果存在且仅存在一个/块棋无气
2.1 这块棋是己方颜色的，不可落下（禁入点）
2.2 这块棋是对方颜色的，可落下
3. 如果存在两个棋块无气，则判断是否在打劫
3.1.如果在打劫
3.1.1如果出现全局同型，不可落下
3.1.2如果未出现全局同型，可落下，提走对方全部子
3.2如果不在打劫，提走对方全部子，落下这颗子
4. 如果存在三块及以上棋块无气，提走对方全部子

打劫判定：
查询对比之前2步的棋局全盘记录，如果出现“全同”，判定不可提劫
```

```
modi. 修改二维列表变量board变量名为current_board，用于记录当前的棋局全盘
```

## 2024_09_16 and 2024_09_17

```
modi. GO类增加pos_to_coordinate方法，便于将鼠标点击位置转化为坐标

describe..如何判断棋局中的死子
module:判断一次当前棋局死子状态
对每个子判断是否存在有气的可能性
opti:判断是出现的一团死子全部标记
contradiction:单次全局标记和单子搜索的标记不完全重合，需要整合
reso.分析判断气的this_chess_can_exist和judge_capture两个方法具体实现方式，尝试厘清功能

```
```
this_chess_can_exist方法分析：

具体实现流程分析：
针对当前子
如果当前子已经被访问，返回True
标记这颗子已经被访问
如果这颗子有气，则这颗子可以存在，返回True
如果邻接同色子全部被访问过，则这颗子不能存在，返回False
如果邻接同色子未被访问，则判定邻接的这颗子是否可存在（递归）
如果存在邻接同色子可存在，则这颗子可存在，返回True

整体情况分析：


>>将访问体系和死棋体系分开
标记已访问用于优化，标记当前死棋是中间量，再用死棋体系记录死棋
```

```
class GO:
modi. 新增变量dead_groups为棋盘大小2维度[True/False,'.'/'B'/'W']类型
modi. 修改变量board_is_visited为visited_area
modi. 新增变量onetime_visited_area，用于记录单次搜索访问过的位置，便于记录死棋
modi. 重命名变量move_order_record为move_sequence_list
modi. 新增变量full_board_log，记录时序全盘情况，用于判断劫争
modi. 暂时停止支持前进、后退的功能
```

```
Q.F. 仅落黑棋、仅落白棋和正常行棋功能不完善，容易出现落子颜色不清晰的问题
modi. 暂停仅黑棋、仅白棋的功能

Q.F. 标记死子即可，颜色可以从current_board获取
modi. 将变量dead_groups修改为只有真假值，放弃颜色

modi. 新增删除死子功能，基于死子标记和对方判定

Q.F. 暂时不知道怎么判定在劫争中，但是好像也不需要判定
```

### Formal BUG Check

```
BUG. 吃单子失败
reso. 设置手动调试点，查看程序逻辑，分析问题所在

BUG. mark_dead_group方法一次也没运行成功过
reso! 弱智bug->visited_area设置的是未访问为False,而我在mark_dead_group里第一个判断条件“如果这个子已经被访问，当作活棋返回True”当作访问是False了，调整即可

NEW BUG. 棋子落下之前的棋被清空
Found.清除死子模块运作
Found.dead_group全部变为False，初始化正常，怀疑死子判定逻辑
reso. oneTime_visited_area同步到dead_groups放入条件not self.mark_dead_group(x, y)中，排除了有气的棋和空位也被计入死棋的情况
modi. 判定死棋模块新增空位不判定

BUG. 吃子时疑似是去除了相反的子
Found. 落子颜色正常，死棋块数判定应该正常，禁入点（死棋块数为1）正常
modi. 缩小判定范围，暂时认定当且仅当两块死棋时需要判定劫争
BUG Cause Found. 死棋1块时判定存在逻辑问题，会当成禁入点情况无法落子，需要对死棋颜色进行判定
modi. 对死棋颜色进行标记，并判定，增加死棋颜色及其种数判定，增加一块死棋特判
modi. 修改基本落子逻辑对一块死棋的判定
BUG FIX. 解决一块死棋禁入点判定误区，可以正常提子
```

```
BUG. 劫争判定还是有问题，无法落子
```

今天太晚了，就到这里

Daily Updating!!!

## 2024_09_18

继续查BUG

```
BUG. 劫争判定无法落子问题

Found. check_ko()方法，cur_pos>2边界值判定正常
modi. 修复判断逻辑错误，兜底返回not_in_ko_state
Found. self.cur_pos此处出现“不统一”，为尚未落子时手数，cur_pos在判定能落子时才会改变（非bug诱因）
modi. 修改判定全同时对比 currnt_board 与 full_board_log[self.cur_pos - 1]
Found. self.full_board_log存储数量正常

Error!! 全同判定前提是先提子
```

```
BUG FOUND! self.full_board_log在判断劫争时异常，所有手数的棋局全部变为最后一手时的棋局
FOUND. 怀疑是浅拷贝的问题，只复制了地址，并不是真正的复制值
BUG FIX 引入模块copy，深拷贝对每个current_board创建副本，实现真正的拷贝，解决了赋值时只赋了地址的问题
```

```
Structural Issue.
全同判定时比较的是落子、提子后的局面是否全同
目前是在判断能否落子的局面下进行比较，
即尚未提子，无法比较是否全同

FIX 将current_board进行deepcopy获取副本，对副本进行提对方死子操作，再进行全同判断
modi. 修改delete_dead_stones方法，添加参数board表示要操作的棋局；
    测试正常删除子正常
modi. 在劫争判断模块中，增加参数current_board_copy，并在判断全同前提死子
Issue closed
```

基本问题解决

开始最后的算法逻辑测试，随即选取yh上的棋谱，还原棋局

### 测试
- **单元测试**: 通过上述检验，所有模块化功能均已通过测试。
- **集成测试**: 经以下检验，均无问题

```
1. 2024_09_18 第49棋日本名人战挑战赛第3/7局 一力辽vs芝野虎丸 涉及 劫争、吃单子、吃多块棋 均无问题
2. 2024_09_15 第1届中国晋城围棋职业公开赛32强 许嘉阳vs时越 涉及 劫争、边角 无问题
3. 2024_09_11 李昌镐vs申真谞 三劫循环 无问题
```

今天就开发到这（开心

## 2024_09_19

### 版本信息

- **软件版本**: 1.0.0
- **依赖**:
  - python: 3.8.10
  - pygame: 2.6.0

### 后续计划

- 增进“处理记录GO落子的数据集方案”word文件记录，明确可行的落子逻辑及记录方案
- 背景上绘制坐标
- 显示最后落子
- 记录并显示双方提子数量
- 恢复交替落子、只下黑棋、只下白棋功能，增加停一手功能
- 棋子上显示对应手数